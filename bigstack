#!/usr/bin/python3
#
#    bigstack: format stack size reports from GCC's -fstack-usage output
#    Copyright (C) 2020 Jeremy Grosser <jeremy@synack.me>
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
import collections
import argparse
import os.path
import os
import json


LICENSE = '''
    Copyright (C) 2020 Jeremy Grosser <jeremy@synack.me>
    This program comes with ABSOLUTELY NO WARRANTY
    This is free software, and you are welcome to redistribute it
    under certain conditions. See LICENSE for a copy of GPL-3.'''
DESCRIPTION = 'bigstack: format stack size reports from GCC\'s -fstack-usage output\n' + LICENSE


Allocation = collections.namedtuple('Allocation', 'source_file line_number column_number symbol_name stack_size allocation_type')


def print_column(args, allocations):
    if not allocations:
        return
    source_file_len = max([len('%s:%d' % (x.source_file, x.line_number)) for x in allocations])
    symbol_name_len = max([len(x.symbol_name) for x in allocations])
    stack_size_len = max([len(str(x.stack_size)) for x in allocations])
    spacing = 1

    for a in allocations:
        source_file = '%s:%d' % (a.source_file, a.line_number)
        print(
            source_file.ljust(source_file_len + spacing),
            a.symbol_name.ljust(symbol_name_len + spacing),
            str(a.stack_size).ljust(stack_size_len + spacing),
            a.allocation_type)


def print_csv(args, allocations):
    print(','.join(Allocation._fields))
    for a in allocations:
        print(','.join([str(x) for x in a]))


def print_json(args, allocations):
    allocations = [x._asdict() for x in allocations]
    print(json.dumps(allocations, indent=2))


FORMATS = {
    'column': print_column,
    'csv': print_csv,
    'json': print_json,
}


def main():
    parser = argparse.ArgumentParser(
            description=DESCRIPTION,
            formatter_class=argparse.RawDescriptionHelpFormatter,
            add_help=False)
    parser.add_argument('filename', nargs='*', help='Path to .su file generated by gcc\'s -fstack-usage flag')
    parser.add_argument('--max', '-m', type=int, help='Only output symbols that have stacks >= MAX', default=-1)
    parser.add_argument('--limit', '-n', type=int, help='Limit output to the top N largest stacks', default=-1)
    parser.add_argument('--reverse', '-r', action='store_true', help='Reverse sort, smallest stacks first')
    parser.add_argument('--long', '-v', action='store_true', help='Output full paths to source files')
    parser.add_argument('--format', '-f', choices=FORMATS.keys(), default='column', help='Output format')

    args = parser.parse_args()

    if not args.filename:
        parser.print_help()
        return 1

    allocations = list()
    for filename in args.filename:
        with open(filename, 'r') as fd:
            for line in fd:
                symbol, stack_size, allocation_type = line.strip('\r\n').split('\t')
                stack_size = int(stack_size)
                if stack_size < args.max:
                    continue
                source_file, line_number, column_number, symbol_name = symbol.split(':', 3)
                if not args.long:
                    source_file = os.path.basename(source_file)
                alloc = (source_file, int(line_number), int(column_number), symbol_name, stack_size, allocation_type)
                allocations.append(Allocation(*alloc))

    allocations.sort(key=lambda x: x.stack_size, reverse=not args.reverse)
    formatter = FORMATS.get(args.format)
    if args.limit > 0:
        allocations = allocations[:args.limit]
    formatter(args, allocations)


if __name__ == '__main__':
    main()
